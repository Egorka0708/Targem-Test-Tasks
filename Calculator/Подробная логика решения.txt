Подробная логика решения задачи.

Прежде всего входное выражение необходимо проверить на правильность ввода и правильно запарсить,
чтобы в дальнейшем с ним было удобно работать. За основу решения я взял алгоритм обратной польской записи,
который подразумевает разделение на операнды (числа) и операторы (знаки), поэтому при парсинге
мне нужно было получить такой массив элементов, в котором разделялись бы операнды и операторы,
но имели бы какой-то один общий тип, чтобы с ними удобно можно было работать. Это уже элемент наследования,
потому я написал интерфейс IToken и создал два типа данных - числовой токен (NumberToken) и оператор токен
(OperatorToken), которые его реализуют. Далее в ParseEquation.Parse происходит сам парсинг выражения,
путём "если это число или часть числа, то добавь его в numberBuilder, а если это знак, то, если в
numberBuilder есть число, то добавь это число в результат как NumberToken, после чего добавь знак в 
результат как OperatorToken".

В SolveEquation находится экземпляр парсера и конструктор для присваивания значения этому парсеру,
а также словарь приоритетов операторов. Через метод Calculate вызываются все необходимые методы для вычисления 
итогового результата:
-Происходит парсинг выражения на токены чисел и операторов
-Удаляются все унарные операторы: -Х становится (0-Х), а +Х становится Х
-Выражение в начальной инфиксной нотации преобразуется в постфиксную (обратная польская запись)
(алгоритм: https://ru.wikipedia.org/wiki/Обратная_польская_запись#Алгоритм )
-Вычисляется значение выражения в обратной польской записи и возвращается результат

